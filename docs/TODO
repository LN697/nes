Phase 2: Advanced Graphics (The Visuals)
Goal: Make Mario appear and the screen scroll.

5. Implement Scrolling
Currently, your renderer draws Nametable 0 at (0,0).

[ ] Read Fine X: Use the fine_x register you added to offset the pixel rendering.

[ ] Read Coarse X/Y: Use v_ram_addr (Loopy V) to determine the starting tile.

[ ] Implement Wrap-around: When rendering reaches pixel 256, wrap to the other nametable (controlled by the Mirroring logic).

6. The "Sprite 0 Hit" (The Gatekeeper)
SMB will hang at the start of World 1-1 if this is missing.

[ ] Collision Logic: In your rendering loop (or PPU step), detect if an opaque pixel of Sprite #0 (the first sprite in OAM) overlaps with an opaque pixel of the background.

[ ] Set Flag: If they collide, set Bit 6 of $2002 (Status) immediately.

[ ] Timing: This must happen at the specific scanline and cycle where the intersection occurs.

Phase 3: Audio (The Voice)
Goal: Generate sound.

The NES APU (Audio Processing Unit) is driven by the CPU clock.

7. Pulse Channels (Square Waves)
These play the melody and sound effects (Coin, Jump).

[ ] Oscillators: Create a PulseChannel class.

[ ] Duty Cycle: Implement the 4 duty cycles (12.5%, 25%, 50%, 75%) controlled by $4000 / $4004.

[ ] Timer: Implement the frequency timer (Low/High bytes at $4002/3).

[ ] Envelope: Implement volume decay.

8. Triangle Channel
The bass line.

[ ] Linear Counter: The unique feature of the triangle channel ($4008).

[ ] Staircase Wave: Generate the 32-step pseudo-sine wave.

9. Noise Channel
Percussion and explosions.

[ ] LFSR: Implement the Linear Feedback Shift Register (15-bit) for random number generation.

10. SDL2 Audio Integration
[ ] SDL_OpenAudioDevice: Initialize an audio stream (e.g., 44100Hz, Float32).

[ ] The Mixer: Every frame, sum the output of the channels: Output = Pulse1 + Pulse2 + Triangle + Noise + DMC.

[ ] Sampling: Downsample the NES audio (1.79MHz) to your PC audio (44.1kHz) and push to the SDL queue.

Phase 4: Accuracy (The Heartbeat)
Goal: Fix the physics and glitches.

11. Cycle-Accurate PPU Rendering
Your current "Batch" loop (while cycles < frame) is fast but inaccurate for raster effects.

[ ] Interleaved Execution: Instead of running the CPU for 100 cycles then the PPU for 300, try to sync them tighter.

[ ] Scanline Rendering: Change your Renderer to draw one scanline at a time inside PPU::step().

[ ] Sprite 0 Timing: Ensure the Sprite 0 flag is set exactly when the PPU renders that pixel, so the CPU (which is polling $2002 in a tight loop) sees it immediately.

12. Save/Load state features